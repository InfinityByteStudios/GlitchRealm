rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ================================
    // Reviews Collection
    // ================================
    match /reviews/{reviewId} {
  // Read: Anyone can read approved reviews,
  //        users can read their own pending reviews,
  //        developers and admins can read all reviews
  allow read: if resource.data.moderationStatus == 'approved' || 
         (request.auth != null && request.auth.uid == resource.data.userId) ||
         isAdmin(request.auth.uid) ||
         isDeveloper(request.auth.uid);
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId &&
                       isValidReview(request.resource.data);
      
      // Update: Only review author can update their own reviews
      allow update: if request.auth != null &&
                       request.auth.uid == resource.data.userId &&
                       isValidReview(request.resource.data) &&
                       // Prevent users from changing moderation status
                       request.resource.data.moderationStatus == resource.data.moderationStatus;
      
      // Delete: Only admins can delete reviews
      allow delete: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // Review Replies Collection
    // ================================
    match /review_replies/{replyId} {
      allow read: if true; // Publicly readable
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId;
      
      // Update: Only reply author can update their own replies
      allow update: if request.auth != null &&
                       request.auth.uid == resource.data.userId;
      
      // Delete: Only admins and reply authors can delete
      allow delete: if request.auth != null && 
                       (request.auth.uid == resource.data.userId || isAdmin(request.auth.uid));
    }
    
    // ================================
    // Game Playtime Collection
    // ================================
    match /playtime/{playTimeId} {
      // Read: Users can read their own playtime doc
      // Support either a stored userId field OR the doc ID being the userId
      allow read: if request.auth != null && (
                     request.auth.uid == resource.data.userId ||
                     request.auth.uid == playTimeId
                   );
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId &&
                       isValidPlaytime(request.resource.data);
      
      // Update: Only the user can update their own playtime
      // (requires valid schema at top-level)
      allow update: if request.auth != null &&
                       (request.auth.uid == resource.data.userId || request.auth.uid == playTimeId) &&
                       isValidPlaytime(request.resource.data);
      
      // Delete: Only admins can delete playtime records
      allow delete: if isAdmin(request.auth.uid);
    }

    // Subcollection: per-game playtime documents at /playtime/{userId}/games/{gameDocId}
    match /playtime/{userId}/games/{gameDocId} {
      // Read: Only the owner can read their per-game playtime
      allow read: if request.auth != null && request.auth.uid == userId;

      // Create/Update: Only the owner can write their per-game playtime
      // (Do not enforce isValidPlaytime here since these docs may use different fields like totalMinutes)
      allow create, update: if request.auth != null && request.auth.uid == userId;

      // Delete: Admins only
      allow delete: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // Admin Actions Collection
    // ================================
    match /adminActions/{actionId} {
      allow read, write: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // User Profiles
    // ================================
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }
    
    // ================================
    // Other Collections (Authenticated Read-Only by default)
    // Explicit write rules must be defined per collection above.
    match /{document=**} {
      allow read: if request.auth != null;
    }
    
    // ================================
    // Helper Functions
    // ================================
    // Community Posts Collection: Public reads for published, writes restricted
    match /community_posts/{postId} {
      // Anyone can read published posts; owners and admins can read their drafts/others
      allow read: if resource.data.status == 'published' ||
                   (request.auth != null && request.auth.uid == resource.data.userId) ||
                   isAdmin(request.auth.uid);

  // Loosened: any authenticated user can create valid posts (owner check removed)
  allow create: if request.auth != null &&
         isValidCommunityPost(request.resource.data);

      // Only the owner can update their post (admins may use delete for moderation)
      allow update: if request.auth != null &&
                     request.auth.uid == resource.data.userId &&
                     isValidCommunityPost(request.resource.data);

      // Only admins can delete posts
      allow delete: if isAdmin(request.auth.uid);

      // Comments subcollection under each post
      match /comments/{commentId} {
        // Publicly readable
        allow read: if true;
        // Create: authenticated users can comment with valid data
        allow create: if request.auth != null && isValidComment(request.resource.data);
        // Update/Delete: only author or admin
        allow update, delete: if request.auth != null && (request.auth.uid == resource.data.userId || isAdmin(request.auth.uid));
      }
    }

    function isValidReview(reviewData) {
      return reviewData.keys().hasAll(['rating', 'gameId', 'userId', 'moderationStatus', 'timestamp']) &&
             reviewData.rating is int &&
             reviewData.rating >= 1 &&
             reviewData.rating <= 5 &&
             reviewData.gameId is string &&
             reviewData.gameId.size() > 0 &&
             reviewData.userId is string &&
             reviewData.userId.size() > 0 &&
             reviewData.moderationStatus in ['approved', 'pending', 'rejected', 'blocked'] &&
             reviewData.timestamp is timestamp &&
             (!reviewData.keys().hasAny(['comment']) || 
              (reviewData.comment is string && reviewData.comment.size() <= 500)) &&
             (!reviewData.keys().hasAny(['userDisplayName']) ||
              (reviewData.userDisplayName is string && reviewData.userDisplayName.size() <= 50)) &&
             (!reviewData.keys().hasAny(['gameName']) ||
              (reviewData.gameName is string && reviewData.gameName.size() <= 100)) &&
             (!reviewData.keys().hasAny(['reason']) ||
              (reviewData.reason is string && reviewData.reason.size() <= 200)) &&
             // Ensure no malicious fields
             !reviewData.keys().hasAny(['admin', 'isAdmin', 'role', 'permissions']);
    }
    
    function isValidPlaytime(playtimeData) {
      return playtimeData.keys().hasAll(['gameId', 'userId', 'hours', 'lastUpdated']) &&
             playtimeData.gameId is string &&
             isValidGameId(playtimeData.gameId) &&
             playtimeData.userId is string &&
             playtimeData.userId.size() > 0 &&
             playtimeData.hours is number &&
             playtimeData.hours >= 0 &&
             playtimeData.lastUpdated is timestamp &&
             (!playtimeData.keys().hasAny(['iconUrl']) || 
              (playtimeData.iconUrl is string && playtimeData.iconUrl.size() > 0)) &&
             (!playtimeData.keys().hasAny(['gameName']) || 
              (playtimeData.gameName is string && playtimeData.gameName.size() > 0));
    }

    // Validate a community post payload
    function isValidCommunityPost(postData) {
      return postData.keys().hasAll(['title','body','userId','createdAt','updatedAt','status']) &&
             postData.title is string && postData.title.size() > 0 && postData.title.size() <= 200 &&
             postData.body is string && postData.body.size() > 0 && postData.body.size() <= 10000 &&
             postData.userId is string && postData.userId.size() > 0 &&
             postData.createdAt is timestamp &&
             postData.updatedAt is timestamp &&
             postData.status in ['published','draft','archived'] &&
             (!postData.keys().hasAny(['tags']) || (
               postData.tags is list && postData.tags.size() <= 10
             )) &&
             (!postData.keys().hasAny(['authorName']) || (postData.authorName is string && postData.authorName.size() <= 100)) &&
             (!postData.keys().hasAny(['authorPhotoUrl']) || (postData.authorPhotoUrl is string && postData.authorPhotoUrl.size() <= 2000)) &&
             (!postData.keys().hasAny(['likesCount']) || (postData.likesCount is int && postData.likesCount >= 0)) &&
             (!postData.keys().hasAny(['commentsCount']) || (postData.commentsCount is int && postData.commentsCount >= 0)) &&
             // Ensure no privilege-escalation fields
             !postData.keys().hasAny(['admin','isAdmin','role','permissions']);
    }
    
    function isAdmin(userId) {
      return userId in [
        'admin-uid-1',
        'admin-uid-2',
        'replace-with-your-admin-uid'
      ];
    }
    
    // Developer accounts allowed to moderate/reply to reviews
    function isDeveloper(userId) {
      return userId in [
        '6iZDTXC78aVwX22qrY43BOxDRLt1',
        'YR3c4TBw09aK7yYxd7vo0AmI6iG3', 
        'g14MPDZzUzR9ELP7TD6IZgk3nzx2',
        '4oGjihtDjRPYI0LsTDhpXaQAJjk1',
        'ZEkqLM6rNTZv1Sun0QWcKYOIbon1'
      ];
    }
    
    function isValidGameId(gameId) {
      return gameId in [
        'coderunner',
        'neurocore',
        'neurocore-byte-wars',
        'bytesurge',
        'shadowlight'
      ];
    }

    // Validate a comment payload under community posts
    function isValidComment(commentData) {
      return commentData.keys().hasAll(['body','userId','createdAt']) &&
             commentData.body is string && commentData.body.size() > 0 && commentData.body.size() <= 2000 &&
             commentData.userId is string && commentData.userId.size() > 0 &&
             commentData.createdAt is timestamp &&
             (!commentData.keys().hasAny(['authorName']) || (commentData.authorName is string && commentData.authorName.size() <= 100)) &&
             (!commentData.keys().hasAny(['authorPhotoUrl']) || (commentData.authorPhotoUrl is string && commentData.authorPhotoUrl.size() <= 2000)) &&
             (!commentData.keys().hasAny(['likesCount']) || (commentData.likesCount is int && commentData.likesCount >= 0)) &&
             // Prevent privilege-escalation fields
             !commentData.keys().hasAny(['admin','isAdmin','role','permissions']);
    }
  }
}
