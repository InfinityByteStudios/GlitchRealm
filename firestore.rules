rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    
    // ================================
    // Reviews Collection
    // ================================
    match /reviews/{reviewId} {
  // Read: Anyone can read approved reviews,
  //        users can read their own pending reviews,
  //        developers and admins can read all reviews
  allow read: if resource.data.moderationStatus == 'approved' || 
         (request.auth != null && request.auth.uid == resource.data.userId) ||
         isAdmin(request.auth.uid) ||
         isDeveloper(request.auth.uid);
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId &&
                       isValidReview(request.resource.data);
      
      // Update: Only review author can update their own reviews
      allow update: if request.auth != null &&
                       request.auth.uid == resource.data.userId &&
                       isValidReview(request.resource.data) &&
                       // Prevent users from changing moderation status
                       request.resource.data.moderationStatus == resource.data.moderationStatus;
      
      // Delete: Only admins can delete reviews
      allow delete: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // Review Replies Collection
    // ================================
    match /review_replies/{replyId} {
      allow read: if true; // Publicly readable
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId;
      
      // Update: Only reply author can update their own replies
      allow update: if request.auth != null &&
                       request.auth.uid == resource.data.userId;
      
      // Delete: Only admins and reply authors can delete
      allow delete: if request.auth != null && 
                       (request.auth.uid == resource.data.userId || isAdmin(request.auth.uid));
    }
    
    // ================================
    // Game Playtime Collection
    // ================================
    match /playtime/{playTimeId} {
      // Read: Users can read their own playtime doc
      // Support either a stored userId field OR the doc ID being the userId
      allow read: if request.auth != null && (
                     request.auth.uid == resource.data.userId ||
                     request.auth.uid == playTimeId
                   );
      
      // Create: Authenticated users only
      allow create: if request.auth != null &&
                       request.auth.uid == request.resource.data.userId &&
                       isValidPlaytime(request.resource.data);
      
      // Update: Only the user can update their own playtime
      // (requires valid schema at top-level)
      allow update: if request.auth != null &&
                       (request.auth.uid == resource.data.userId || request.auth.uid == playTimeId) &&
                       isValidPlaytime(request.resource.data);
      
      // Delete: Only admins can delete playtime records
      allow delete: if isAdmin(request.auth.uid);
    }

    // Subcollection: per-game playtime documents at /playtime/{userId}/games/{gameDocId}
    match /playtime/{userId}/games/{gameDocId} {
      // Read: Only the owner can read their per-game playtime
      allow read: if request.auth != null && request.auth.uid == userId;

      // Create/Update: Only the owner can write their per-game playtime
      // (Do not enforce isValidPlaytime here since these docs may use different fields like totalMinutes)
      allow create, update: if request.auth != null && request.auth.uid == userId;

      // Delete: Admins only
      allow delete: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // Admin Actions Collection
    // ================================
    match /adminActions/{actionId} {
      allow read, write: if isAdmin(request.auth.uid);
    }

    // ================================
    // Community Post Reports (Moderation)
    // ================================
    match /community_post_reports/{reportId} {
  // Admins, developers, and the reporter can read
  allow read: if request.auth != null && (isAdmin(request.auth.uid) || isDeveloper(request.auth.uid) || request.auth.uid == resource.data.userId);
      // Any authenticated user can create their own report
      allow create: if request.auth != null &&
                    request.auth.uid == request.resource.data.userId &&
                    isValidReport(request.resource.data);
      // Only admins can update/delete reports (e.g., resolve)
      allow update, delete: if isAdmin(request.auth.uid);
    }
    
    // ================================
    // User Profiles
    // ================================
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
      
        // Per-user hidden posts for the community
        match /hidden_posts/{postId} {
          allow read: if request.auth != null && request.auth.uid == userId;
          allow create, update: if request.auth != null && request.auth.uid == userId &&
                                request.resource.data.keys().hasOnly(['hiddenAt']) &&
                                request.resource.data.hiddenAt is timestamp;
          allow delete: if request.auth != null && request.auth.uid == userId;
        }
    }
    
    // ================================
    // Other Collections (Authenticated Read-Only by default)
    // Explicit write rules must be defined per collection above.
    match /{document=**} {
      allow read: if request.auth != null;
    }
    
    // ================================
    // Helper Functions
    // ================================
    // Community Posts Collection: Public reads for published, writes restricted
    match /community_posts/{postId} {
      // Anyone can read published posts; owners and admins can read their drafts/others
      allow read: if resource.data.status == 'published' ||
                   (request.auth != null && request.auth.uid == resource.data.userId) ||
                   isAdmin(request.auth.uid);

  // Loosened: any authenticated user can create valid posts (owner check removed)
  allow create: if request.auth != null &&
         isValidCommunityPost(request.resource.data);

  // Only the owner can update their post (admins may use delete for moderation)
  allow update: if request.auth != null &&
         request.auth.uid == resource.data.userId &&
         isValidCommunityPost(request.resource.data) &&
         (!request.resource.data.keys().hasAny(['pinned']) || request.resource.data.pinned == resource.data.pinned);

  // Allow safe likesCount-only updates by any authenticated user (for upvotes)
  allow update: if request.auth != null && isLikesCountOnlyUpdate();

  // Admins can toggle only the 'pinned' flag
  allow update: if request.auth != null && isAdmin(request.auth.uid) && isPinOnlyUpdate();

  // Delete: owner or admin can delete posts
  allow delete: if request.auth != null && (request.auth.uid == resource.data.userId || isAdmin(request.auth.uid));

      // Comments subcollection under each post
      match /comments/{commentId} {
        // Publicly readable
        allow read: if true;
        // Create: authenticated users can comment with valid data
        allow create: if request.auth != null && isValidComment(request.resource.data);
        // Update/Delete: only author or admin
        allow update, delete: if request.auth != null && (request.auth.uid == resource.data.userId || isAdmin(request.auth.uid));
      }

      // Likes (Upvotes) subcollection under each post
      match /likes/{uid} {
        // Only the owner of the like can read their like doc (used to mark UI state)
        allow read: if request.auth != null && request.auth.uid == uid;
        // Create: user creates their own like doc with basic schema
        allow create: if request.auth != null &&
                       request.auth.uid == uid &&
                       request.resource.data.keys().hasOnly(['userId','createdAt']) &&
                       request.resource.data.userId == uid &&
                       request.resource.data.createdAt is timestamp;
        // Delete: user can remove their own like; admins too
        allow delete: if request.auth != null && (request.auth.uid == uid || isAdmin(request.auth.uid));
        // No updates to like docs (delete/recreate)
        allow update: if false;
      }
    }

    function isValidReview(reviewData) {
      return reviewData.keys().hasAll(['rating', 'gameId', 'userId', 'moderationStatus', 'timestamp']) &&
             reviewData.rating is int &&
             reviewData.rating >= 1 &&
             reviewData.rating <= 5 &&
             reviewData.gameId is string &&
             reviewData.gameId.size() > 0 &&
             reviewData.userId is string &&
             reviewData.userId.size() > 0 &&
             reviewData.moderationStatus in ['approved', 'pending', 'rejected', 'blocked'] &&
             reviewData.timestamp is timestamp &&
             (!reviewData.keys().hasAny(['comment']) || 
              (reviewData.comment is string && reviewData.comment.size() <= 500)) &&
             (!reviewData.keys().hasAny(['userDisplayName']) ||
              (reviewData.userDisplayName is string && reviewData.userDisplayName.size() <= 50)) &&
             (!reviewData.keys().hasAny(['gameName']) ||
              (reviewData.gameName is string && reviewData.gameName.size() <= 100)) &&
             (!reviewData.keys().hasAny(['reason']) ||
              (reviewData.reason is string && reviewData.reason.size() <= 200)) &&
             // Ensure no malicious fields
             !reviewData.keys().hasAny(['admin', 'isAdmin', 'role', 'permissions']);
    }
    
    function isValidPlaytime(playtimeData) {
      return playtimeData.keys().hasAll(['gameId', 'userId', 'hours', 'lastUpdated']) &&
             playtimeData.gameId is string &&
             isValidGameId(playtimeData.gameId) &&
             playtimeData.userId is string &&
             playtimeData.userId.size() > 0 &&
             playtimeData.hours is number &&
             playtimeData.hours >= 0 &&
             playtimeData.lastUpdated is timestamp &&
             (!playtimeData.keys().hasAny(['iconUrl']) || 
              (playtimeData.iconUrl is string && playtimeData.iconUrl.size() > 0)) &&
             (!playtimeData.keys().hasAny(['gameName']) || 
              (playtimeData.gameName is string && playtimeData.gameName.size() > 0));
    }

    // Validate a community post payload
    function isValidCommunityPost(postData) {
      return postData.keys().hasAll(['title','body','userId','createdAt','updatedAt','status']) &&
             postData.title is string && postData.title.size() > 0 && postData.title.size() <= 200 &&
             postData.body is string && postData.body.size() > 0 && postData.body.size() <= 10000 &&
             postData.userId is string && postData.userId.size() > 0 &&
             postData.createdAt is timestamp &&
             postData.updatedAt is timestamp &&
             postData.status in ['published','draft','archived'] &&
             (!postData.keys().hasAny(['tags']) || (
               postData.tags is list && postData.tags.size() <= 10
             )) &&
             (!postData.keys().hasAny(['authorName']) || (postData.authorName is string && postData.authorName.size() <= 100)) &&
             (!postData.keys().hasAny(['authorPhotoUrl']) || (postData.authorPhotoUrl is string && postData.authorPhotoUrl.size() <= 2000)) &&
             (!postData.keys().hasAny(['likesCount']) || (postData.likesCount is int && postData.likesCount >= 0)) &&
             (!postData.keys().hasAny(['commentsCount']) || (postData.commentsCount is int && postData.commentsCount >= 0)) &&
             // Ensure no privilege-escalation fields
             !postData.keys().hasAny(['admin','isAdmin','role','permissions']);
    }
    
    function isAdmin(userId) {
      return (request.auth != null && request.auth.token.admin == true) ||
             userId in [
               'admin-uid-1',
               'admin-uid-2',
               'replace-with-your-admin-uid'
             ];
    }
    
    // Developer accounts allowed to moderate/reply to reviews
    function isDeveloper(userId) {
      return userId in [
        '6iZDTXC78aVwX22qrY43BOxDRLt1',
        'YR3c4TBw09aK7yYxd7vo0AmI6iG3', 
        'g14MPDZzUzR9ELP7TD6IZgk3nzx2',
        '4oGjihtDjRPYI0LsTDhpXaQAJjk1',
        'ZEkqLM6rNTZv1Sun0QWcKYOIbon1'
      ];
    }
    
    function isValidGameId(gameId) {
      return gameId in [
        'coderunner',
        'neurocore',
        'neurocore-byte-wars',
        'bytesurge',
        'shadowlight'
      ];
    }

    // Validate a comment payload under community posts
    function isValidComment(commentData) {
      return commentData.keys().hasAll(['body','userId','createdAt']) &&
             commentData.body is string && commentData.body.size() > 0 && commentData.body.size() <= 2000 &&
             commentData.userId is string && commentData.userId.size() > 0 &&
             commentData.createdAt is timestamp &&
             (!commentData.keys().hasAny(['authorName']) || (commentData.authorName is string && commentData.authorName.size() <= 100)) &&
             (!commentData.keys().hasAny(['authorPhotoUrl']) || (commentData.authorPhotoUrl is string && commentData.authorPhotoUrl.size() <= 2000)) &&
             (!commentData.keys().hasAny(['likesCount']) || (commentData.likesCount is int && commentData.likesCount >= 0)) &&
             // Prevent privilege-escalation fields
             !commentData.keys().hasAny(['admin','isAdmin','role','permissions']);
    }

    // Allow only likesCount field to change, keeping it >= 0
    function isLikesCountOnlyUpdate() {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(['likesCount']) &&
             request.resource.data.likesCount is int &&
             request.resource.data.likesCount >= 0;
    }

    // Allow only 'pinned' to change (admin-controlled)
    function isPinOnlyUpdate() {
      return request.resource.data.diff(resource.data).changedKeys().hasOnly(['pinned']) &&
             request.resource.data.pinned is bool;
    }

    // Validate a moderation report document
    function isValidReport(reportData) {
      return reportData.keys().hasAll(['postId','userId','reason','status','createdAt']) &&
             reportData.postId is string && reportData.postId.size() > 0 &&
             reportData.userId is string && reportData.userId.size() > 0 &&
             reportData.reason is string && reportData.reason.size() > 0 && reportData.reason.size() <= 500 &&
             reportData.status in ['open','reviewing','resolved','rejected'] &&
             reportData.createdAt is timestamp;
    }
  }
}
